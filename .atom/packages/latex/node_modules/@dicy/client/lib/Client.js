"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const cp = require("child_process");
const rpc = require("vscode-jsonrpc");
class Builder extends events_1.EventEmitter {
    constructor(cache, file) {
        super();
        this.cache = cache;
        this.file = file;
        this.logListener = (file, messages) => {
            if (file === this.file)
                this.emit('log', messages);
        };
        this.cache.on('log', this.logListener);
    }
    destroy() {
        this.cache.removeListener('log', this.logListener);
    }
    getTargets() {
        return this.cache.getTargets(this.file);
    }
    kill(message) {
        return this.cache.kill(this.file, message);
    }
    run(commands) {
        return this.cache.run(this.file, commands);
    }
    setInstanceOptions(options, merge) {
        return this.cache.setInstanceOptions(this.file, options, merge);
    }
    setUserOptions(options, merge) {
        return this.cache.setUserOptions(this.file, options, merge);
    }
    setDirectoryOptions(options, merge) {
        return this.cache.setDirectoryOptions(this.file, options, merge);
    }
    setProjectOptions(options, merge) {
        return this.cache.setProjectOptions(this.file, options, merge);
    }
}
class Client extends events_1.EventEmitter {
    constructor(autoStart = false) {
        super();
        /** @internal */
        this.cachedBuilders = new Map();
        /** @internal */
        this.clearRequest = new rpc.RequestType1('clear');
        /** @internal */
        this.clearAllRequest = new rpc.RequestType0('clearAll');
        /** @internal */
        this.getTargetsRequest = new rpc.RequestType1('getTargets');
        /** @internal */
        this.exitNotification = new rpc.NotificationType0('exit');
        /** @internal */
        this.killRequest = new rpc.RequestType2('kill');
        /** @internal */
        this.killAllRequest = new rpc.RequestType1('killAll');
        /** @internal */
        this.logNotification = new rpc.NotificationType2('log');
        /** @internal */
        this.runRequest = new rpc.RequestType2('run');
        /** @internal */
        this.setDirectoryOptionsRequest = new rpc.RequestType3('setDirectoryOptions');
        /** @internal */
        this.setInstanceOptionsRequest = new rpc.RequestType3('setInstanceOptions');
        /** @internal */
        this.setProjectOptionsRequest = new rpc.RequestType3('setProjectOptions');
        /** @internal */
        this.setUserOptionsRequest = new rpc.RequestType3('setUserOptions');
        this.autoStart = autoStart;
    }
    /** @internal */
    bootstrap() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.autoStart && !this.server)
                yield this.start();
        });
    }
    createTransport() {
        const serverPath = require.resolve('@dicy/server');
        this.server = cp.fork(serverPath, ['--node-ipc']);
        this.server.on('exit', () => {
            delete this.server;
            delete this.connection;
        });
        return [new rpc.IPCMessageReader(this.server), new rpc.IPCMessageWriter(this.server)];
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = this.createTransport();
            this.connection = rpc.createMessageConnection(transport[0], transport[1]);
            this.connection.onNotification(this.logNotification, (file, messages) => {
                this.emit('log', file, messages);
            });
            this.connection.listen();
        });
    }
    exit() {
        try {
            this.connection.sendNotification(this.exitNotification);
        }
        finally {
            this.server.kill();
        }
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.exit();
        });
    }
    get(file) {
        return __awaiter(this, void 0, void 0, function* () {
            let builder = this.cachedBuilders.get(file);
            if (!builder) {
                builder = new Builder(this, file);
                this.cachedBuilders.set(file, builder);
            }
            return builder;
        });
    }
    getTargets(file) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.getTargetsRequest, file);
        });
    }
    clear(file) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.clearRequest, file);
        });
    }
    clearAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.clearAllRequest);
        });
    }
    kill(file, message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.killRequest, file, message);
        });
    }
    killAll(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.killAllRequest, message);
        });
    }
    setInstanceOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.setInstanceOptionsRequest, file, options, merge);
        });
    }
    setUserOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.setUserOptionsRequest, file, options, merge);
        });
    }
    setDirectoryOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.setDirectoryOptionsRequest, file, options, merge);
        });
    }
    setProjectOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.setProjectOptionsRequest, file, options, merge);
        });
    }
    run(file, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.bootstrap();
            return this.connection.sendRequest(this.runRequest, file, commands);
        });
    }
}
exports.default = Client;
