"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const url2path = require('file-uri-to-path');
const Builder_1 = require("./Builder");
class BuilderCache extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.cachedBuilders = new Map();
    }
    get(file) {
        return __awaiter(this, void 0, void 0, function* () {
            let builder = this.cachedBuilders.get(file);
            if (!builder) {
                builder = yield Builder_1.default.create(url2path(file));
                this.cachedBuilders.set(file, builder);
                builder.on('log', (messages) => this.emit('log', file, messages));
            }
            return builder;
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.killAll();
            yield this.clearAll();
        });
    }
    setInstanceOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.setInstanceOptions(options, merge);
        });
    }
    setUserOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.setUserOptions(options, merge);
        });
    }
    setProjectOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.setProjectOptions(options, merge);
        });
    }
    setDirectoryOptions(file, options, merge) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.setDirectoryOptions(options, merge);
        });
    }
    getTargets(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.getTargets();
        });
    }
    clear(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = this.cachedBuilders.get(file);
            if (builder) {
                builder.removeAllListeners();
                this.cachedBuilders.delete(file);
            }
        });
    }
    clearAll() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const builder of this.cachedBuilders.values()) {
                builder.removeAllListeners();
            }
            this.cachedBuilders.clear();
        });
    }
    kill(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            yield builder.kill();
        });
    }
    killAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const killJobs = Array.from(this.cachedBuilders.values()).map(builder => builder.kill());
            yield Promise.all(killJobs);
        });
    }
    run(file, commands) {
        return __awaiter(this, void 0, void 0, function* () {
            const builder = yield this.get(file);
            return builder.run(commands);
        });
    }
}
exports.default = BuilderCache;
