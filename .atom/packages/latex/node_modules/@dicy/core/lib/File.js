"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const _ = require("lodash");
const commandJoin = require('command-join');
const crypto = require("crypto");
const fs = require("fs-extra");
const path = require("path");
const readline = require("readline");
const yaml = require("js-yaml");
class File {
    /**
     * Construct a new File. Because creating a file required asynchronous file
     * system access this method is used only to initialize the File instance. Used
     * the `create` method to actual create an instance.
     * @param  {string}    realFilePath The actual file system path.
     * @param  {string}    filePath     The file path relative to the project root.
     * @param  {FileCache} fileCache    The timestamp, hash and value provided by cache.
     */
    constructor(realFilePath, filePath, fileCache) {
        // If it is a virtual or a physical file. Virtual files are usually in-memory
        // copies of parsed files such as log files.
        this.virtual = false;
        // Read only files cannot be deleted nor have their value changed
        this.readOnly = false;
        // Job names currently associated with the file.
        this.jobNames = new Set();
        // Has the file been analyzed in the current cycle?
        this.analyzed = false;
        // Has the file been updated in the current cycle?
        this._hasBeenUpdated = false;
        // Has the file been changed during the current run?
        this.hasBeenUpdatedCache = false;
        this.realFilePath = realFilePath;
        this.filePath = filePath;
        if (fileCache) {
            this.timeStamp = fileCache.timeStamp;
            if (fileCache.hash)
                this.hash = fileCache.hash;
            if (fileCache.value)
                this._value = fileCache.value;
        }
    }
    /**
     * Create a new File.
     * @param  {string}    realFilePath The actual file system path.
     * @param  {string}    filePath     The file path relative to the project root.
     * @param  {FileCache} fileCache    The timestamp, hash and value provided by cache.
     * @return {File}                   The File instance.
     */
    static create(realFilePath, filePath, fileCache) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = new File(realFilePath, filePath, fileCache);
            yield file.findType();
            // If the file type is not a virtual file type and there is no physical file
            // then just quit.
            if (!file.virtual && !(yield File.canRead(realFilePath)))
                return undefined;
            // Check for an update to file in case it has changed since the cache was
            // finalized.
            yield file.update();
            return file;
        });
    }
    /**
     * Load the file types from the resource file `resources/file-types.yaml`
     */
    static loadFileTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.fileTypes) {
                const fileTypesPath = path.resolve(__dirname, '..', 'resources', 'file-types.yaml');
                const value = (yield this.readYaml(fileTypesPath));
                // Create a new map and iterate through each type in the file and save it
                // to the map.
                this.fileTypes = new Map();
                for (const name in value) {
                    this.fileTypes.set(name, value[name]);
                }
            }
        });
    }
    static read(filePath) {
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, { encoding: 'utf-8' }, (error, data) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(data.toString());
                }
            });
        });
    }
    static readYaml(filePath, fullSchema = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yield File.read(filePath);
            return yaml.load(contents, {
                schema: fullSchema ? yaml.DEFAULT_FULL_SCHEMA : yaml.DEFAULT_SAFE_SCHEMA
            });
        });
    }
    static write(filePath, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield fs.mkdirp(path.dirname(filePath));
            yield fs.writeFile(filePath, value, { encoding: 'utf-8' });
        });
    }
    static writeYaml(filePath, value, fullSchema = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yaml.dump(value, {
                skipInvalid: true,
                schema: fullSchema ? yaml.DEFAULT_FULL_SCHEMA : yaml.DEFAULT_SAFE_SCHEMA
            });
            yield fs.mkdirp(path.dirname(filePath));
            yield fs.writeFile(filePath, contents, { encoding: 'utf-8' });
        });
    }
    static canRead(filePath) {
        return new Promise((resolve, reject) => {
            fs.access(filePath, fs.constants.R_OK, error => resolve(!error));
        });
    }
    static getModifiedTime(filePath) {
        return new Promise((resolve, reject) => {
            fs.stat(filePath, (error, stat) => resolve(error ? new Date() : stat.mtime));
        });
    }
    static isFile(filePath) {
        return new Promise((resolve, reject) => {
            fs.stat(filePath, (error, stat) => resolve(!error && stat.isFile()));
        });
    }
    static isDirectory(filePath) {
        return new Promise((resolve, reject) => {
            fs.stat(filePath, (error, stat) => resolve(!error && stat.isDirectory()));
        });
    }
    static remove(filePath) {
        return new Promise((resolve, reject) => {
            fs.remove(filePath, error => error ? reject(error) : resolve());
        });
    }
    static ensureDir(filePath) {
        return new Promise((resolve, reject) => {
            fs.ensureDir(filePath, error => error ? reject(error) : resolve());
        });
    }
    static copy(from, to) {
        return new Promise((resolve, reject) => {
            fs.copy(from, to, error => error ? reject(error) : resolve());
        });
    }
    /**
     * Parse the file using a list of Parsers.
     * @param  {Parser[]}      parsers   List of parsers to apply.
     * @param  {string => boolean}  isWrapped A function to test for line wrapping.
     */
    parse(parsers, isWrapped = line => false) {
        return new Promise((resolve, reject) => {
            // The maximum number of lines that we need to maintain in a buffer to
            // satisfy all the parsers.
            const bufferSize = parsers.reduce((current, parser) => Math.max(current, parser.patterns.length), 0);
            // The buffer of unwrapped lines.
            let lines = [];
            let lineNumber = 1;
            let mode = '';
            let modeParsers = [];
            const setMode = (newMode) => {
                mode = newMode;
                modeParsers = parsers.filter(parser => (parser.modes || [File.DEFAULT_PARSING_MODE]).includes(mode));
            };
            // A function to check form matches in all the parsers.
            const checkForMatches = (finalCheck = false) => {
                while (lines.length > 0) {
                    // If this is not the final check then do not check if there is not
                    // enough lines in the buffer to check all parsers.
                    if (!finalCheck && lines.length < bufferSize)
                        break;
                    let matched = false;
                    for (const parser of modeParsers) {
                        // If there is not enough lines to check this parser then skip it.
                        if (parser.patterns.length > lines.length)
                            continue;
                        const matches = parser.patterns.map((pattern, index) => lines[index].text.match(pattern));
                        matched = matches.every(match => !!match);
                        if (matched) {
                            const parserMatch = {
                                _: matches.map(match => match ? match[0] : '').join('\n'),
                                captures: [],
                                groups: {}
                            };
                            if (parser.names) {
                                let m = [];
                                m = m.concat(...matches.map(match => match ? match.slice(1) : []));
                                const names = parser.names || [];
                                names.map((name, index) => {
                                    if (m.length > index)
                                        parserMatch.groups[name] = m[index];
                                });
                            }
                            else {
                                let m = [];
                                m = m.concat(...matches.map(match => match || []));
                                parserMatch.captures = m;
                            }
                            const lineCount = lines.splice(0, parser.patterns.length).reduce((total, line) => total + line.count, 0);
                            const reference = {
                                file: this.filePath,
                                range: {
                                    start: lineNumber,
                                    end: lineNumber + lineCount - 1
                                }
                            };
                            lineNumber += lineCount;
                            const newMode = parser.evaluate(mode, reference, parserMatch);
                            if (newMode)
                                setMode(newMode);
                            break;
                        }
                    }
                    if (!matched) {
                        // No match so pop the leading line from the queue.
                        lineNumber += lines[0].count;
                        lines.shift();
                    }
                }
            };
            setMode(File.DEFAULT_PARSING_MODE);
            if (this.virtual) {
                const rawLines = this.value ? this.value.toString().split(/\r?\n/) : [];
                lines = rawLines.map((text) => ({ text, count: 1 }));
                for (let index = lines.length - 1; index > -1; index--) {
                    if (isWrapped(lines[index].text) && index + 1 < lines.length) {
                        lines[index].text += lines[index + 1].text;
                        lines[index].count += lines[index + 1].count;
                        lines.splice(index + 1, 1);
                    }
                }
                checkForMatches(true);
                resolve();
            }
            else {
                let current = { text: '', count: 0 };
                const rl = readline.createInterface({
                    input: fs.createReadStream(this.realFilePath, { encoding: 'utf-8' })
                });
                rl
                    .on('line', line => {
                    current.text += line;
                    current.count += 1;
                    if (!isWrapped(line)) {
                        lines.push(current);
                        current = { text: '', count: 0 };
                        checkForMatches();
                    }
                })
                    .on('close', () => {
                    checkForMatches(true);
                    resolve();
                });
            }
        });
    }
    /**
     * Getter for `hasBeenUpdated`
     * @return {Boolean}  Update status.
     */
    get hasBeenUpdated() {
        return this._hasBeenUpdated;
    }
    /**
     * Setter for `hasBeenUpdated`
     * @param {Boolean}  value  Update status.
     */
    set hasBeenUpdated(value) {
        this._hasBeenUpdated = value;
        // Cache the update flag in case it gets reset in the cycle.
        this.hasBeenUpdatedCache = value || this.hasBeenUpdatedCache;
    }
    restoreUpdateFlag() {
        this.hasBeenUpdated = this.hasBeenUpdatedCache;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (this.readOnly)
            return;
        if (!_.isEqual(value, this._value)) {
            this.hasBeenUpdated = true;
            this.timeStamp = new Date();
        }
        this._value = value;
    }
    /**
     * Find the type of a file by iterating through the available types and
     * testing each one.
     * @return {void}
     */
    findType() {
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure the file types are loaded
            yield File.loadFileTypes();
            // Go through each file type and test each one. Break when we find a match.
            for (const [type, properties] of File.fileTypes.entries()) {
                if (yield this.isFileType(type, properties))
                    break;
            }
        });
    }
    /**
     * Test a file to see if it matches the supplied FileType.
     * @param  {String}   name     The name of the file type
     * @param  {FileType} fileType The FileType descriptor
     * @return {Boolean}           True if the file matches the file type, false
     *                             otherwise.
     */
    isFileType(name, fileType) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the file type descriptor does not have a pattern for the file name or
            // a pattern for the contents of the file then it must be a virtual file.
            if (!fileType.fileName && !fileType.contents) {
                // Test to see if the file path ends in the file type's name.
                const isMatch = this.realFilePath.endsWith(`-${name}`);
                if (isMatch) {
                    // Its a match so set the file type.
                    this.type = name;
                    this.virtual = true;
                }
                return isMatch;
            }
            // If file name does not match required pattern then just quit.
            if (fileType.fileName && !fileType.fileName.test(this.realFilePath)) {
                return false;
            }
            // Does the file type descriptor require specific file contents pattern?
            if (fileType.contents) {
                // Make sure the file is readable.
                if (yield this.canRead()) {
                    const contents = yield this.read();
                    const [value = undefined, subType = undefined] = contents.match(fileType.contents || '') || [];
                    if (value) {
                        // We have a match so set the type and sub type.
                        this.type = name;
                        this.subType = subType;
                        return true;
                    }
                }
            }
            else {
                // No specific contents required so we have a successful match!
                this.type = name;
                return true;
            }
            return false;
        });
    }
    inTypeSet(types) {
        return types.has('*') || types.has(this.type);
    }
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.virtual)
                yield File.remove(this.realFilePath);
        });
    }
    /**
     * Update the file time stamp
     * @return {boolean}  true if time stamp has been updated, false otherwise.
     */
    updateTimeStamp() {
        return __awaiter(this, void 0, void 0, function* () {
            // If it is a virtual file then we only update the time stamp when `value`
            // is set.
            if (this.virtual)
                return false;
            // Save the old time stamp and get the current one.
            const oldTimeStamp = this.timeStamp;
            this.timeStamp = yield File.getModifiedTime(this.realFilePath);
            // Return true indicating an updated time stamp if there was no time stamp
            // before or the new time stamp is more recent.
            return !oldTimeStamp || oldTimeStamp < this.timeStamp;
        });
    }
    updateHash() {
        const fileType = File.fileTypes.get(this.type);
        if (this.virtual || path.isAbsolute(this.filePath))
            return Promise.resolve(true);
        return new Promise((resolve, reject) => {
            // const fileType = File.fileTypes.get(this.type)
            const hash = crypto.createHash('sha256');
            const finish = () => {
                const oldHash = this.hash;
                this.hash = hash.digest('base64');
                resolve(oldHash !== this.hash);
            };
            if (fileType && fileType.hashFilter) {
                const command = commandJoin([fileType.hashFilter, this.realFilePath]);
                childProcess.exec(command, {}, (error, stdout, stderr) => {
                    if (error) {
                        resolve(true);
                    }
                    else {
                        for (const line of stdout.toString().split(/\n/g)) {
                            if (!fileType.hashSkip || !fileType.hashSkip.test(line))
                                hash.update(line);
                        }
                        finish();
                    }
                });
            }
            else if (fileType && fileType.hashSkip) {
                const rl = readline.createInterface({
                    input: fs.createReadStream(this.realFilePath, { encoding: 'utf-8' })
                });
                rl
                    .on('line', line => {
                    if (!fileType.hashSkip || !fileType.hashSkip.test(line))
                        hash.update(line);
                })
                    .on('close', finish);
            }
            else {
                fs.createReadStream(this.realFilePath)
                    .on('data', data => hash.update(data))
                    .on('end', finish);
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            const updated = (yield this.updateTimeStamp()) && (yield this.updateHash());
            this.hasBeenUpdated = this.hasBeenUpdated || updated;
        });
    }
    read() {
        return File.read(this.realFilePath);
    }
    readYaml() {
        return File.readYaml(this.realFilePath);
    }
    write(value) {
        return File.write(this.realFilePath, value);
    }
    canRead() {
        return File.canRead(this.realFilePath);
    }
    copy(to) {
        return File.copy(this.realFilePath, to);
    }
}
File.DEFAULT_PARSING_MODE = 'default';
exports.default = File;
