"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const path = require("path");
const readdir = require("readdir-enhanced");
const types_1 = require("@dicy/types");
const State_1 = require("./State");
const StateConsumer_1 = require("./StateConsumer");
const File_1 = require("./File");
const VALID_COMMAND_PATTERN = /^(build|clean|graph|load|log|save|scrub|test)$/;
class Builder extends StateConsumer_1.default {
    constructor() {
        super(...arguments);
        this.consumers = new Map();
    }
    static create(filePath, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = yield types_1.getOptionDefinitions();
            const state = new State_1.default(filePath, schema);
            const builder = new Builder(state, state.getJobOptions());
            yield builder.initialize();
            yield builder.setInstanceOptions(options);
            builder.assignOptions(options);
            return builder;
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const ruleClassPath = path.join(__dirname, 'Rules');
            const entries = yield readdir.async(ruleClassPath);
            this.ruleClasses = entries
                .map(entry => require(path.join(ruleClassPath, entry)).default);
        });
    }
    getConsumer(jobName) {
        let consumer = this.consumers.get(jobName);
        if (!consumer) {
            consumer = new StateConsumer_1.default(this.state, this.getJobOptions(jobName));
            this.consumers.set(jobName, consumer);
        }
        return consumer;
    }
    analyzePhase(command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkForKill();
            for (const ruleClass of this.ruleClasses) {
                const jobNames = ruleClass.ignoreJobName ? [null] : this.options.jobNames;
                for (const jobName of jobNames) {
                    const rule = yield ruleClass.analyzePhase(this.getConsumer(jobName), command, phase);
                    if (rule) {
                        yield this.addRule(rule);
                    }
                }
            }
        });
    }
    analyzeFiles(command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkForKill();
            while (true) {
                const file = Array.from(this.files).find(file => !file.analyzed);
                if (!file)
                    break;
                for (const ruleClass of this.ruleClasses) {
                    const jobNames = file.jobNames.size === 0 ? [null] : Array.from(file.jobNames.values());
                    for (const jobName of jobNames) {
                        const rules = yield ruleClass.analyzeFile(this.getConsumer(jobName), command, phase, file);
                        for (const rule of rules) {
                            yield this.addRule(rule);
                        }
                    }
                }
                file.analyzed = true;
            }
        });
    }
    getAvailableRules(command) {
        return this.ruleClasses
            .filter(rule => !command || rule.commands.has(command))
            .map(rule => ({ name: rule.name, description: rule.description }));
    }
    evaluateRule(rule, action) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkForKill();
            if (rule.failures.has(action)) {
                this.info(`Skipping rule ${rule.id} because of previous failure.`);
                return false;
            }
            yield rule.evaluate(action);
            return true;
        });
    }
    evaluate(command, phase, action) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkForKill();
            const primaryCount = (ruleGroup) => ruleGroup.reduce((total, rule) => total + rule.parameters.reduce((count, parameter) => parameter.filePath === this.filePath ? count + 1 : count, 0), 0);
            const evaluationNeeded = (rule) => rule.actions.has(action) && rule.command === command && rule.phase === phase;
            // First separate the rule graph into connected components. For each
            // component only retain rules that are pertinent to the current command,
            // phase and action. Rank the rules in the component by the number of other
            // rules that it is directly dependent on within the same component. Only
            // retain those that have the lowest dependency rank. Sort the remaining
            // rules by number of inputs in an ascending order. Finally sort the
            // components by number of primaries in an ascending order. A rule is
            // considered a primary is it has as an input the main source file for that
            // job. Note: we are using lodash's sortBy because the standard sort is
            // not guaranteed to be a stable sort.
            const rules = _.flatten(_.sortBy(this.components
                .map(component => {
                const ruleGroup = _.sortBy(component.filter(evaluationNeeded), [(rule) => rule.inputs.length]);
                return ruleGroup.reduce((current, rule) => {
                    // Rank the rule by how many other rules it is directly dependent on.
                    const rank = ruleGroup.reduce((count, otherRule) => this.isGrandparentOf(rule, otherRule) ? count + 1 : count, 0);
                    // The rank is lower than the current rank so start a new list.
                    if (rank < current.rank)
                        return { rank, rules: [rule] };
                    // The ranks is the same as the current rank so just add us to the
                    if (rank === current.rank)
                        current.rules.push(rule);
                    // list.
                    return current;
                }, { rank: Number.MAX_SAFE_INTEGER, rules: [] }).rules;
            }), [primaryCount]));
            if (rules.length === 0)
                return false;
            let didEvaluation = false;
            for (const rule of rules) {
                yield this.checkUpdates(command, phase);
                didEvaluation = (yield this.evaluateRule(rule, action)) || didEvaluation;
            }
            yield this.checkUpdates(command, phase);
            return didEvaluation;
        });
    }
    checkUpdates(command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkForKill();
            for (const file of this.files) {
                for (const rule of this.getInputRules(file)) {
                    yield rule.addFileActions(file, command, phase);
                }
                file.hasBeenUpdated = false;
            }
        });
    }
    kill(message = 'Build was killed.') {
        if (!this.killToken)
            return Promise.resolve();
        if (!this.killToken.promise) {
            this.killToken.error = new Error(message);
            this.killToken.promise = new Promise(resolve => {
                if (this.killToken)
                    this.killToken.resolve = resolve;
                this.killChildProcesses();
            });
        }
        return this.killToken.promise;
    }
    run(commands) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.killToken) {
                this.error('Build currently in progress');
                return false;
            }
            const invalidCommands = commands.filter(command => !VALID_COMMAND_PATTERN.test(command));
            if (invalidCommands.length !== 0) {
                this.error(`Aborting due to receiving the following invalid commands: ${invalidCommands.join(', ')}`);
                return false;
            }
            this.killToken = {};
            let success = true;
            const phases = ['initialize', 'execute', 'finalize'];
            try {
                for (const command of commands) {
                    for (const phase of phases) {
                        yield this.runPhase(command, phase);
                    }
                }
                success = Array.from(this.rules).every(rule => rule.failures.size === 0);
            }
            catch (error) {
                success = false;
                this.error(error.stack);
            }
            finally {
                if (this.killToken && this.killToken.resolve) {
                    success = false;
                    this.killToken.resolve();
                }
                this.killToken = null;
            }
            return success;
        });
    }
    runPhase(command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            const actions = ['parse', 'updateDependencies', 'run'];
            this.checkForKill();
            for (const file of this.files) {
                file.restoreUpdateFlag();
                file.analyzed = false;
            }
            for (const rule of this.rules) {
                yield rule.phaseInitialize(command, phase);
            }
            yield this.analyzePhase(command, phase);
            for (let cycle = 0; cycle < this.options.phaseCycles; cycle++) {
                let didEvaluation = false;
                for (const action of actions) {
                    yield this.analyzeFiles(command, phase);
                    didEvaluation = (yield this.evaluate(command, phase, action)) || didEvaluation;
                }
                if (Array.from(this.files).every(file => file.analyzed) &&
                    Array.from(this.rules).every(rule => rule.command !== command || rule.phase !== phase || !rule.needsEvaluation))
                    break;
                if (!didEvaluation)
                    break;
            }
        });
    }
    setInstanceOptions(options, merge = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.setOptions(yield this.getFile('dicy-instance.yaml-ParsedYAML'), options, merge);
        });
    }
    setUserOptions(options, merge = false) {
        return this.setOptions('$CONFIG_HOME/dicy/config.yaml', options, merge);
    }
    setDirectoryOptions(options, merge = false) {
        return this.setOptions('$ROOTDIR/.dicy.yaml', options, merge);
    }
    setProjectOptions(options, merge = false) {
        return this.setOptions('$ROOTDIR/$NAME.yaml', options, merge);
    }
    setOptions(file, options = {}, merge = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!file) {
                this.error('Unable to set options.');
                return;
            }
            const normalizedOptions = {};
            if (typeof file === 'string')
                file = this.resolvePath(file);
            if (merge) {
                let current;
                if (typeof file === 'string') {
                    if (yield File_1.default.canRead(file)) {
                        current = yield File_1.default.readYaml(file);
                    }
                }
                else {
                    current = file.value;
                }
                if (current) {
                    this.assignOptions(current, normalizedOptions);
                }
                else {
                    this.warning('Unable to retrieve current options.');
                }
            }
            this.assignOptions(options, normalizedOptions);
            if (typeof file === 'string') {
                yield File_1.default.writeYaml(file, normalizedOptions);
            }
            else {
                file.readOnly = false;
                file.value = normalizedOptions;
                file.readOnly = true;
            }
        });
    }
}
exports.default = Builder;
