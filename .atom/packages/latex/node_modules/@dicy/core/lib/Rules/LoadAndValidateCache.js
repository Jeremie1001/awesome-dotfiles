"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const File_1 = require("../File");
const Rule_1 = require("../Rule");
const types_1 = require("../types");
class LoadAndValidateCache extends Rule_1.default {
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cacheFilePath = this.resolvePath('$ROOTDIR/$NAME-cache.yaml');
        });
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.loadCache) {
                if ((yield File_1.default.canRead(this.cacheFilePath)) && (!this.cacheTimeStamp ||
                    this.cacheTimeStamp < (yield File_1.default.getModifiedTime(this.cacheFilePath)))) {
                    this.info('Loading build cache from disk as it is newer then in-memory build cache.');
                    yield this.loadCache();
                }
                else {
                    if (this.options.validateCache) {
                        this.info('Validating in-memory build cache.');
                        yield this.validateCache();
                    }
                    else {
                        this.info('Skipping cache validation since `validateCache` is not set.');
                    }
                }
            }
            else {
                this.info('Skipping loading build cache from disk since `loadCache` is not set.');
                yield this.cleanCache();
            }
            // Get the main source file just in case it wasn't added by the cache load.
            // This also lets the cache load test for a change in the main source file.
            yield this.getFile(this.filePath);
            return true;
        });
    }
    cleanCache() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const jobName of this.options.jobNames) {
                for (const file of this.files) {
                    yield this.deleteFile(file, jobName, false);
                }
            }
            for (const rule of Array.from(this.rules)) {
                this.removeRule(rule);
            }
        });
    }
    loadCache() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cleanCache();
            this.cacheTimeStamp = yield File_1.default.getModifiedTime(this.cacheFilePath);
            const cache = yield File_1.default.readYaml(this.cacheFilePath);
            if (!cache)
                return true;
            if (!cache.version) {
                this.warning('Skipping load of build cache since no version tag was found in the cache.');
                return true;
            }
            else if (!semver.satisfies(cache.version, `^${types_1.CACHE_VERSION}`)) {
                this.warning(`Skipping load of build cache since version tag \`v${cache.version}\` does not match \`^${types_1.CACHE_VERSION}\`.`);
                return true;
            }
            this.resetOptions();
            this.assignOptions(cache.options);
            if (cache.files) {
                for (const filePath in cache.files) {
                    yield this.addCachedFile(filePath, cache.files[filePath]);
                }
            }
            if (cache.rules) {
                for (const rule of cache.rules) {
                    yield this.addCachedRule(rule);
                }
            }
        });
    }
    validateCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const file of this.files) {
                if (!file.virtual) {
                    if (yield file.canRead()) {
                        yield file.update();
                    }
                    else {
                        files.push(file);
                    }
                }
            }
            for (const jobName of this.options.jobNames) {
                for (const file of files) {
                    yield this.deleteFile(file, jobName, false);
                }
            }
            for (const file of this.files) {
                file.restoreUpdateFlag();
            }
            for (const rule of this.rules) {
                for (const input of rule.inputs) {
                    yield rule.addFileActions(input);
                }
            }
        });
    }
}
LoadAndValidateCache.phases = new Set(['initialize']);
LoadAndValidateCache.commands = new Set(['load']);
LoadAndValidateCache.alwaysEvaluate = true;
LoadAndValidateCache.ignoreJobName = true;
LoadAndValidateCache.description = 'Loads the file/rule cache from a previous build.';
exports.default = LoadAndValidateCache;
