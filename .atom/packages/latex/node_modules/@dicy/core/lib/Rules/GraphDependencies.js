"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const File_1 = require("../File");
const Rule_1 = require("../Rule");
const COMMAND_PHASE_JOB_NAME_PATTERN = /\(([^;)]*);([^;)]*);([^;)]*);?/;
class GraphDependencies extends Rule_1.default {
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            let lines = [];
            const rulesByCommand = _.groupBy(Array.from(this.rules), rule => rule.command);
            let level = 0;
            function addLine(line) {
                lines.push(_.repeat(' ', 2 * level) + line);
            }
            function startGraph(name, label) {
                if (name && label) {
                    addLine(`subgraph "cluster_${name}" {`);
                    level++;
                    addLine(`label = "${label}";`);
                }
                else {
                    addLine('digraph {');
                }
            }
            function endGraph() {
                level--;
                addLine('}');
            }
            startGraph();
            for (const command in rulesByCommand) {
                startGraph(command, `${command} command`);
                const rulesByPhase = _.groupBy(rulesByCommand[command], rule => rule.phase);
                for (const phase in rulesByPhase) {
                    switch (phase) {
                        case 'execute':
                            addLine(`"cluster_${command};initialize" -> "cluster_${command};execute";`);
                            break;
                        case 'finalize':
                            addLine(`"cluster_${command};execute" -> "cluster_${command};finalize";`);
                            break;
                    }
                    startGraph(`${command};${phase}`, `${phase} phase`);
                    const rulesByJobName = _.groupBy(rulesByPhase[phase], rule => rule.options.jobName);
                    for (const jobName in rulesByJobName) {
                        if (jobName !== 'undefined') {
                            startGraph(`${command};${phase};${jobName}`, `\\"${jobName}\\" job`);
                        }
                        const rules = rulesByJobName[jobName] || [];
                        for (let i = 0; i < rules.length; i++) {
                            // let connected = false
                            for (let j = 0; j < rules.length; j++) {
                                const from = this.isGrandparentOf(rules[i], rules[j]);
                                const to = this.isGrandparentOf(rules[j], rules[i]);
                                if (from) {
                                    if (!to) {
                                        addLine(`"${rules[i].id}" -> "${rules[j].id}";`);
                                    }
                                    else if (i <= j) {
                                        addLine(`"${rules[i].id}" -> "${rules[j].id}" [dir="both"];`);
                                    }
                                }
                            }
                            addLine(`"${rules[i].id}" [shape=box,label="${rules[i].id.replace(COMMAND_PHASE_JOB_NAME_PATTERN, '(')}"];`);
                        }
                        if (jobName !== 'undefined')
                            endGraph();
                    }
                    endGraph();
                }
                endGraph();
            }
            endGraph();
            const filePath = this.resolvePath('$ROOTDIR/$OUTDIR/$NAME-graph.dot');
            yield File_1.default.write(filePath, lines.join('\n'));
            yield this.getOutput(filePath);
            return true;
        });
    }
}
GraphDependencies.commands = new Set(['graph']);
GraphDependencies.alwaysEvaluate = true;
GraphDependencies.ignoreJobName = true;
GraphDependencies.description = 'Creates a GraphViz dependency graph.';
exports.default = GraphDependencies;
