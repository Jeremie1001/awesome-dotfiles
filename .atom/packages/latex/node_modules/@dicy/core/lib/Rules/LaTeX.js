"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Log_1 = require("../Log");
const Rule_1 = require("../Rule");
const PDF_CAPABLE_LATEX_PATTERN = /^(pdf|xe|lua)latex$/;
const JAPANESE_LATEX_PATTERN = /^u?platex$/;
const RERUN_LATEX_PATTERN = /(rerun LaTeX|(?:Citation|Label)\(s\) may have changed\. Rerun|No file |Point totals have changed. Rerun to get point totals right.)/i;
const SUB_FILE_SUB_TYPES = ['subfile', 'standalone'];
class LaTeX extends Rule_1.default {
    static isApplicable(consumer, command, phase, parameters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return parameters.some(file => ((file.type === 'LaTeX' && (file.filePath === consumer.filePath || !SUB_FILE_SUB_TYPES.includes(file.subType || ''))) ||
                (file.type === 'LiterateHaskell' && consumer.options.literateHaskellEngine === 'none') ||
                (file.type === 'LiterateAgda' && consumer.options.literateAgdaEngine === 'none')));
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getResolvedInputs([
                '$OUTDIR/$JOB.fls-ParsedFileListing',
                '$OUTDIR/$JOB.log-ParsedLaTeXLog'
            ]);
        });
    }
    getFileActions(file) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (file.type) {
                case 'ParsedFileListing':
                    return ['updateDependencies'];
                case 'ParsedLaTeXLog':
                    // If a rerun instruction is found then return run, otherwise just
                    // return updateDependencies.
                    return (file.value && !!Log_1.default.findMessage(file.value, RERUN_LATEX_PATTERN))
                        ? ['updateDependencies', 'run']
                        : ['updateDependencies'];
                default:
                    return ['run'];
            }
        });
    }
    constructCommand() {
        const engine = this.options.engine;
        // Add engine and common options
        const args = [
            engine,
            '-file-line-error',
            '-interaction=batchmode',
            '-recorder'
        ];
        if (this.options.outputDirectory) {
            args.push(`-output-directory=${this.options.outputDirectory}`);
        }
        if (this.options.jobName) {
            args.push(`-jobname=${this.options.jobName}`);
        }
        if (this.options.synctex) {
            args.push('-synctex=1');
        }
        switch (this.options.shellEscape) {
            case 'disabled':
                args.push('-no-shell-escape');
                break;
            case 'restricted':
                args.push('-shell-restricted');
                break;
            case 'enabled':
                args.push('-shell-escape');
                break;
        }
        // xelatex uses a different option to specify dvi output since it runs
        // xdvipdfmx internally.
        if (PDF_CAPABLE_LATEX_PATTERN.test(engine)) {
            if (this.options.outputFormat !== 'pdf') {
                switch (this.options.engine) {
                    case 'xelatex':
                        args.push('-no-pdf');
                        break;
                    default:
                        args.push('-output-format=dvi');
                        break;
                }
            }
        }
        if (JAPANESE_LATEX_PATTERN.test(engine)) {
            if (this.options.kanji) {
                args.push(`-kanji=${this.options.kanji}`);
            }
            if (this.options.kanjiInternal) {
                args.push(`-kanji-internal=${this.options.kanjiInternal}`);
            }
        }
        // Add the source file.
        args.push('{{$FILEPATH_0}}');
        return {
            args,
            cd: '$ROOTDIR',
            severity: 'error',
            inputs: [{ file: '$OUTDIR/$JOB.aux' }],
            outputs: [
                { file: '$OUTDIR/$JOB.aux' },
                { file: '$OUTDIR/$JOB.fls' },
                { file: '$OUTDIR/$JOB.log' },
                { file: '$OUTDIR/$JOB.synctex.gz', type: 'target' },
                { file: '$OUTDIR/$JOB$OUTEXT', type: 'target' }
            ]
        };
    }
}
LaTeX.parameterTypes = [new Set([
        'LaTeX',
        'LiterateHaskell',
        'LiterateAgda'
    ])];
LaTeX.description = 'Runs the required latex variant.';
exports.default = LaTeX;
