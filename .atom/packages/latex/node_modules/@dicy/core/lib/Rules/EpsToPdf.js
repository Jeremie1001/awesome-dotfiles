"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Log_1 = require("../Log");
const Rule_1 = require("../Rule");
class EpsToPdf extends Rule_1.default {
    static isApplicable(consumer, command, phase, parameters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (parameters[1].type) {
                case 'Nil':
                    // If there is not a LaTeX log present then only apply epstopdf when the
                    // main source file is an EPS.
                    return parameters[0].filePath === path.normalize(consumer.options.filePath) &&
                        consumer.options.outputFormat === 'pdf';
                case 'ParsedLaTeXLog':
                    // When there is a LaTeX log present only apply epstopdf if there are
                    // specific calls present, usually from the epstopdf package.
                    return !!EpsToPdf.findCall(parameters[1].value, parameters[0].filePath);
                default:
                    return false;
            }
        });
    }
    /**
     * Find an epstopdf call either in the call list or in an epstopdf package
     * message.
     * @param  {ParsedLog}  parsedLog   The parsed LaTeX log.
     * @param  {string}     filePath    The file path to look for.
     * @return {ShellCall}              The shell call found or null if no
     *                                  matching call was found.
     */
    static findCall(parsedLog, filePath) {
        let call;
        if (parsedLog) {
            // First look for shell escape call.
            call = Log_1.default.findCall(parsedLog, /^r?epstopdf$/, filePath);
            if (!call) {
                // If there is no shell escape call then look for a message from the
                // epstopdf package.
                call = Log_1.default.findMessageMatches(parsedLog, /Command: <([^>]*)>/, 'Package epstopdf')
                    .map(match => Log_1.default.parseCall(match[1]))
                    .find(call => call.args.includes(filePath));
            }
        }
        return call;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.secondParameter.type !== 'Nil') {
                const call = EpsToPdf.findCall(this.parameters[1].value, this.parameters[0].filePath);
                if (call) {
                    // There is a matching call so scrape the options from it.
                    if (call.options.outfile) {
                        this.options.epstopdfOutputPath = call.options.outfile.toString();
                    }
                    else if (call.args.length > 2) {
                        this.options.epstopdfOutputPath = call.args[2];
                    }
                    this.options.epstopdfBoundingBox = call.options.exact
                        ? 'exact'
                        : (call.options.hires ? 'hires' : 'default');
                    this.options.epstopdfRestricted = !!call.options.restricted;
                }
            }
        });
    }
    getFileActions(file) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only return a run action for the actual eps file.
            return file.type === 'EncapsulatedPostScript' ? ['run'] : [];
        });
    }
    preEvaluate() {
        return __awaiter(this, void 0, void 0, function* () {
            const call = EpsToPdf.findCall(this.parameters[1].value, this.parameters[0].filePath);
            if (call && call.status.startsWith('executed')) {
                // There is a matching and successful call so just get the resolved output
                // and skip the evaluation.
                this.info(`Skipping epstopdf call since epstopdf was already executed via shell escape.`);
                yield this.getResolvedOutput(this.options.epstopdfOutputPath);
                this.actions.delete('run');
            }
        });
    }
    constructCommand() {
        const outputPath = this.options.epstopdfOutputPath;
        // Newer versions of epstopdf support the dvipdfm style "epstopdf in out"
        // but for backward compatability we use `--outfile` instead.
        const args = [
            'epstopdf',
            `--outfile={{${outputPath}}}`
        ];
        // Look for a bounding box setting.
        switch (this.options.epstopdfBoundingBox) {
            case 'exact':
                args.push('--exact');
                break;
            case 'hires':
                args.push('--hires');
                break;
        }
        // Use restricted if required even though we are executing outside the
        // context of shell escape.
        if (this.options.epstopdfRestricted) {
            args.push('--restricted');
        }
        args.push('{{$FILEPATH_0}}');
        return {
            args,
            cd: '$ROOTDIR',
            severity: 'error',
            inputs: [{ file: '$FILEPATH_0', type: 'target' }],
            outputs: [{ file: outputPath, type: 'target' }]
        };
    }
}
EpsToPdf.parameterTypes = [
    new Set(['EncapsulatedPostScript']),
    new Set(['ParsedLaTeXLog', 'Nil'])
];
EpsToPdf.description = 'Converts EPS to PDF using epstopdf.';
exports.default = EpsToPdf;
