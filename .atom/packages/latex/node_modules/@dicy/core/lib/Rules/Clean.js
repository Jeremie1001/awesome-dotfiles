"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fastGlob = require("fast-glob");
const micromatch = require("micromatch");
const path = require("path");
const readdir = require("readdir-enhanced");
const File_1 = require("../File");
const Rule_1 = require("../Rule");
class Clean extends Rule_1.default {
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const scrub = this.command === 'scrub';
            const generatedFiles = new Set();
            const files = new Set();
            const directories = new Set();
            if (scrub) {
                directories.add(this.resolvePath('$NAME-cache.yaml'));
            }
            for (const rule of this.rules) {
                if (rule.options.jobName === this.options.jobName) {
                    for (const file of rule.outputs) {
                        if (file.virtual)
                            continue;
                        if (scrub) {
                            files.add(file);
                        }
                        else {
                            generatedFiles.add(file);
                        }
                    }
                }
            }
            for (const pattern of this.options.cleanPatterns) {
                if (/^[/\\]/.test(pattern)) {
                    for (const matchedFilePath of yield this.globPath(pattern.substring(1))) {
                        const filePath = path.resolve(this.rootPath, matchedFilePath);
                        if (yield File_1.default.isFile(filePath)) {
                            const file = yield this.getFile(matchedFilePath);
                            if (file)
                                files.add(file);
                        }
                        else if (yield File_1.default.isDirectory(filePath)) {
                            directories.add(filePath);
                        }
                    }
                }
                else if (!scrub && generatedFiles.size !== 0) {
                    const isMatch = micromatch.matcher(this.resolvePath(pattern), { dot: true });
                    for (const file of generatedFiles.values()) {
                        if (isMatch(file.filePath)) {
                            files.add(file);
                        }
                    }
                }
            }
            for (const file of files.values()) {
                yield this.deleteFile(file, this.options.jobName);
            }
            for (const filePath of directories) {
                yield File_1.default.remove(path.resolve(this.rootPath, filePath));
                this.info(`Deleting \`${filePath}\``, 'file');
            }
            const globOptions = { cwd: this.rootPath, onlyDirectories: true };
            const candidateDirectories = yield fastGlob('**/*', globOptions);
            candidateDirectories.reverse();
            for (const filePath of candidateDirectories) {
                const realFilePath = path.resolve(this.rootPath, filePath);
                const contents = yield readdir.async(realFilePath);
                if (contents.length === 0) {
                    yield File_1.default.remove(realFilePath);
                    this.info(`Deleting \`${filePath}\``, 'file');
                }
            }
            return true;
        });
    }
}
Clean.commands = new Set(['clean', 'scrub']);
Clean.alwaysEvaluate = true;
Clean.description = 'Clean up a previous build.';
exports.default = Clean;
