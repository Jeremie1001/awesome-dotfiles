"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const types_1 = require("@dicy/types");
const Rule_1 = require("../Rule");
class ApplyOptions extends Rule_1.default {
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            // Save the old options so we can tell if they have changed.
            const previousOptions = this.serializedOptions;
            yield this.doAssignOptions();
            this.checkForConfigurationChange(previousOptions);
            return true;
        });
    }
    doAssignOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            // All the possible sources of configuration data with low priority first.
            const optionPaths = [
                'dicy.yaml-ParsedYAML',
                '$NAME.yaml-ParsedYAML',
                '$BASE-ParsedLaTeXMagic',
                'dicy-instance.yaml-ParsedYAML'
            ];
            const inputs = yield this.getResolvedInputs(optionPaths);
            const optionSet = inputs.map(file => file.value || {});
            const loadUserOptions = optionSet.reduce((loadUserOptions, options) => ('loadUserOptions' in options) ? options.loadUserOptions : loadUserOptions, types_1.DEFAULT_OPTIONS.loadUserOptions);
            // Load the user options if loadUserOptions is true.
            if (loadUserOptions) {
                const userOptions = yield this.getResolvedInput('$CONFIG_HOME/dicy/config.yaml-ParsedYAML');
                if (userOptions) {
                    optionSet.unshift(userOptions.value || {});
                }
            }
            else {
                this.info('Ignoring user options since `loadUserOptions` is false.');
            }
            // Reset the options and assign from from the inputs
            this.resetOptions();
            for (const options of optionSet) {
                this.assignOptions(options);
            }
        });
    }
    checkForConfigurationChange(previousOptions) {
        const matcher = (value, other, key) => {
            if (key) {
                const schema = this.getOptionSchema(key.toString());
                if (schema && schema.noInvalidate)
                    return true;
            }
            return undefined;
        };
        if (!_.isMatchWith(this.serializedOptions, previousOptions, matcher)) {
            const rules = Array.from(this.rules)
                .filter(rule => rule.command !== 'load' || rule.phase === 'finalize');
            if (rules.length !== 0) {
                // Something has changed so remove rules that are not load rules or are
                // in the finalize phase.
                this.warning('Options have changed. Resetting all rules.');
                for (const rule of rules) {
                    this.removeRule(rule);
                }
            }
        }
    }
}
ApplyOptions.commands = new Set(['load']);
// ApplyOptions runs in both the initialize and execute phases so that
// instance options will be seen in the initialize phase.
ApplyOptions.phases = new Set(['initialize', 'execute']);
ApplyOptions.alwaysEvaluate = true;
ApplyOptions.ignoreJobName = true;
ApplyOptions.description = 'Apply options from YAML files and any LaTeX magic comments found in source file.';
exports.default = ApplyOptions;
