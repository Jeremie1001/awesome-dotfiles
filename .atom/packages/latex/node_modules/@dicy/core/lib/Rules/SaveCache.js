"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const File_1 = require("../File");
const Rule_1 = require("../Rule");
const types_1 = require("../types");
class SaveCache extends Rule_1.default {
    static isApplicable(consumer, command, phase, parameters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only apply if saveCache is enabled
            return consumer.options.saveCache;
        });
    }
    preEvaluate() {
        return __awaiter(this, void 0, void 0, function* () {
            // If all output files are virtual the don't bother saving.
            if (Array.from(this.rules).every(rule => rule.outputs.every(file => file.virtual))) {
                this.actions.delete('run');
            }
        });
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const cacheFilePath = this.resolvePath('$ROOTDIR/$NAME-cache.yaml');
            const cache = {
                version: types_1.CACHE_VERSION,
                filePath: this.filePath,
                options: this.serializedOptions,
                files: {},
                rules: []
            };
            // Loop through all the files and add them to the cache.
            for (const file of this.files) {
                const fileCache = {
                    timeStamp: file.timeStamp,
                    jobNames: Array.from(file.jobNames.values())
                };
                if (file.value) {
                    fileCache.value = file.value;
                }
                if (file.hash) {
                    fileCache.hash = file.hash;
                }
                if (file.type) {
                    fileCache.type = file.type;
                }
                if (file.subType) {
                    fileCache.subType = file.subType;
                }
                cache.files[file.filePath] = fileCache;
            }
            // Loop through all the rules and add them to the cache.
            for (const rule of this.rules) {
                const ruleCache = {
                    name: rule.constructor.name,
                    command: rule.command,
                    phase: rule.phase,
                    parameters: rule.parameters.map(file => file.filePath),
                    inputs: rule.inputs.map(file => {
                        return { file: file.filePath, type: this.state.edge(file.filePath, rule.id) };
                    }),
                    outputs: rule.outputs.map(file => {
                        return { file: file.filePath, type: this.state.edge(rule.id, file.filePath) };
                    })
                };
                if (rule.options.jobName) {
                    ruleCache.jobName = rule.options.jobName;
                }
                cache.rules.push(ruleCache);
            }
            // Save the cache and update the timestamp.
            yield File_1.default.writeYaml(cacheFilePath, cache);
            this.cacheTimeStamp = yield File_1.default.getModifiedTime(cacheFilePath);
            return true;
        });
    }
}
SaveCache.commands = new Set(['save']);
SaveCache.alwaysEvaluate = true;
SaveCache.ignoreJobName = true;
SaveCache.description = 'Saves file and rule status to a cache (-cache.yaml) to assist with rebuilding.';
exports.default = SaveCache;
