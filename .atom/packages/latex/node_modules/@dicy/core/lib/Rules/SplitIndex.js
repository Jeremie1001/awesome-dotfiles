"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Log_1 = require("../Log");
const Rule_1 = require("../Rule");
class SplitIndex extends Rule_1.default {
    static isApplicable(consumer, command, phase, parameters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedLog = parameters[1].value;
            const base = path.basename(parameters[0].filePath);
            const messagePattern = new RegExp(`(Using splitted index at ${base}|Remember to run \\(pdf\\)latex again after calling \`splitindex')`);
            const wasGeneratedBySplitIndex = consumer.isOutputOf(parameters[0], 'SplitIndex');
            const splitindexCall = !!parsedLog && !!Log_1.default.findCall(parsedLog, 'splitindex', base);
            const splitindexMessage = !!parsedLog && !!Log_1.default.findMessage(parsedLog, messagePattern);
            // Only apply to index control files when there is some indication from the
            // log that we need to.
            return !wasGeneratedBySplitIndex && (splitindexCall || splitindexMessage);
        });
    }
    getFileActions(file) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only return a run action for the actual idx file and updateDependencies
            // for the parsed splitindex output.
            switch (file.type) {
                case 'ParsedSplitIndexStdOut':
                    return ['updateDependencies'];
                case 'ParsedLaTeXLog':
                    return [];
                default:
                    return ['run'];
            }
        });
    }
    preEvaluate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.actions.has('run'))
                return;
            const parsedLog = this.secondParameter.value;
            const { base } = path.parse(this.firstParameter.filePath);
            // If the correct makeindex call is found in the log then delete the run
            // action.
            if (parsedLog) {
                const call = Log_1.default.findCall(parsedLog, 'splitindex', base, 'executed');
                if (call) {
                    this.info('Skipping splitindex call since splitindex was already executed via shell escape.');
                    for (const call of Log_1.default.filterCalls(parsedLog, 'makeindex')) {
                        yield this.getOutputs(call.args.slice(1));
                    }
                    this.actions.delete('run');
                }
            }
        });
    }
    constructCommand() {
        // Be extra verbose and capture all output for parsing
        return {
            args: ['splitindex', '-v', '-v', '-m', '', '{{$FILEPATH_0}}'],
            cd: '$ROOTDIR',
            severity: 'error',
            inputs: [{
                    file: '$DIR_0/$NAME_0.log-ParsedSplitIndexStdOut'
                }],
            stdout: '$DIR_0/$NAME_0.log-SplitIndexStdOut',
            stderr: '$DIR_0/$NAME_0.log-SplitIndexStdErr'
        };
    }
}
SplitIndex.parameterTypes = [
    new Set(['IndexControlFile']),
    new Set(['ParsedLaTeXLog'])
];
SplitIndex.description = 'Runs splitindex on any index files.';
exports.default = SplitIndex;
