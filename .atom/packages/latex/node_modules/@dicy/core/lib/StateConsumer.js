"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const fastGlob = require("fast-glob");
const fileUrl = require('file-url');
const _ = require("lodash");
const path = require("path");
const kill = require("tree-kill");
const VARIABLE_PATTERN = /\$\{?(\w+)\}?/g;
class StateConsumer {
    constructor(state, options, hasLocalOptions = false) {
        this.localOptions = {};
        this.state = state;
        this.options = hasLocalOptions
            ? new Proxy(options, {
                get: (target, key) => {
                    return key in this.localOptions
                        ? this.localOptions[key]
                        : target[key];
                },
                set: (target, key, value) => {
                    this.setOption(this.localOptions, key.toString(), value);
                    return true;
                },
                ownKeys: (target) => {
                    const keys = new Set(Object.keys(this.localOptions));
                    Object.keys(target).forEach(key => keys.add(key));
                    return Array.from(keys.values());
                }
            })
            : options;
        this.env = {
            OUTDIR: this.options.outputDirectory || '.',
            OUTEXT: `.${this.options.outputFormat}`,
            JOB: this.options.jobName || this.state.env.NAME
        };
    }
    isInputTarget(file) {
        return this.state.hasOutEdge(file.filePath, 'target');
    }
    isOutputTarget(file) {
        return this.state.hasInEdge(file.filePath, 'target');
    }
    isTerminalTarget(file) {
        return this.isOutputTarget(file) && !this.isInputTarget(file);
    }
    get targets() {
        return Array.from(this.files).filter(file => this.isTerminalTarget(file));
    }
    getTargets() {
        return Promise.resolve(this.targets.map(file => fileUrl(path.resolve(this.rootPath, file.filePath))));
    }
    get killToken() {
        return this.state.killToken;
    }
    set killToken(value) {
        this.state.killToken = value;
    }
    get cacheTimeStamp() {
        return this.state.cacheTimeStamp;
    }
    set cacheTimeStamp(timeStamp) {
        this.state.cacheTimeStamp = timeStamp;
    }
    get serializedOptions() {
        return _.cloneDeep(this.state.options);
    }
    resetOptions() {
        this.state.resetOptions();
    }
    assignOptions(options, store) {
        if (!store)
            store = this.state.options;
        for (const name in options) {
            const value = options[name];
            if (name === 'jobs') {
                let jobs = store.jobs;
                if (!jobs) {
                    store.jobs = jobs = {};
                }
                for (const jobName in value) {
                    const subOptions = value[jobName];
                    let jobOptions = jobs[jobName];
                    if (!jobOptions) {
                        jobs[jobName] = jobOptions = {};
                    }
                    for (const jobOptionName in subOptions) {
                        this.setOption(jobOptions, jobOptionName, subOptions[jobOptionName]);
                    }
                }
            }
            else {
                this.setOption(store, name, value);
            }
        }
    }
    getOptionSchema(name) {
        return this.state.optionSchema.get(name);
    }
    setOption(store, name, value) {
        const schema = this.state.optionSchema.get(name);
        if (schema) {
            let invalidType = false;
            switch (schema.type) {
                case 'string':
                    invalidType = typeof value !== 'string';
                    break;
                case 'strings':
                    invalidType = !Array.isArray(value) || value.some(x => typeof x !== 'string');
                    break;
                case 'number':
                    invalidType = typeof value !== 'number';
                    break;
                case 'boolean':
                    invalidType = typeof value !== 'boolean';
                    break;
                case 'variable':
                    invalidType = !(typeof value === 'string' ||
                        (Array.isArray(value) && value.every(x => typeof x === 'string')));
                    break;
            }
            if (invalidType || (schema.values && !schema.values.includes(value))) {
                this.warning(`Ignoring attempt to set \`${name}\` to a invalid value of \`${value.toString()}\``);
            }
            else {
                store[schema.name] = value;
            }
        }
        else if (name.startsWith('$')) {
            // It's an environment variable
            store[name] = value;
        }
        else {
            this.warning(`Ignoring attempt to set unknown option \`${name}\` to a value of \`${value.toString()}\``);
        }
    }
    checkForKill() {
        if (this.state.killToken && this.state.killToken.error)
            throw this.state.killToken.error;
    }
    get ruleClasses() {
        return this.state.ruleClasses;
    }
    set ruleClasses(rules) {
        this.state.ruleClasses = rules;
    }
    get filePath() {
        return this.state.filePath;
    }
    get rootPath() {
        return this.state.rootPath;
    }
    get files() {
        return this.state.files.values();
    }
    get rules() {
        return this.state.rules.values();
    }
    deleteFile(file, jobName, unlink = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (file.readOnly)
                return;
            const invalidRules = [];
            for (const rule of this.rules) {
                if (rule.options.jobName || null === jobName) {
                    if (yield rule.removeFileFromRule(file)) {
                        // This file is one of the parameters of the rule so we need to remove
                        // the rule.
                        invalidRules.push(rule);
                    }
                }
            }
            for (const rule of invalidRules) {
                this.removeRule(rule);
            }
            if (jobName)
                file.jobNames.delete(jobName);
            if (file.jobNames.size === 0) {
                if (unlink) {
                    yield file.delete();
                    if (!file.virtual)
                        this.info(`Deleting \`${file.filePath}\``, 'file');
                }
                this.removeFile(file);
            }
        });
    }
    addRule(rule) {
        return this.state.addRule(rule);
    }
    removeRule(rule) {
        this.state.removeRule(rule);
    }
    removeFile(file) {
        this.state.removeFile(file);
    }
    hasRule(id) {
        return this.state.rules.has(id);
    }
    normalizePath(filePath) {
        return this.state.normalizePath(filePath);
    }
    resolvePath(filePath) {
        return path.normalize(this.expandVariables(filePath));
    }
    expandVariables(value, additionalProperties = {}) {
        const properties = Object.assign({}, this.state.env, this.env, additionalProperties);
        return value.replace(VARIABLE_PATTERN, (match, name) => properties[name] || match[0]);
    }
    globPath(pattern, { types = 'all', ignorePattern = [] } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fastGlob(this.expandVariables(pattern), {
                    cwd: this.rootPath,
                    onlyFiles: types === 'files',
                    onlyDirectories: types === 'directories',
                    ignore: ignorePattern
                });
            }
            catch (error) {
                this.error(error.toString());
            }
            return [];
        });
    }
    getFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield this.state.getFile(filePath);
            if (file && this.options.jobName)
                file.jobNames.add(this.options.jobName);
            return file;
        });
    }
    getFiles(filePaths) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of filePaths) {
                const file = yield this.getFile(filePath);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    getGlobbedFiles(pattern) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of yield this.globPath(pattern)) {
                const file = yield this.getFile(filePath);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    error(text, category, name = 'DiCy') {
        this.log(_.pickBy({ severity: 'error', category, name, text }));
    }
    warning(text, category, name = 'DiCy') {
        this.log(_.pickBy({ severity: 'warning', category, name, text }));
    }
    info(text, category, name = 'DiCy') {
        this.log(_.pickBy({ severity: 'info', category, name, text }));
    }
    trace(text, category, name = 'DiCy') {
        this.log(_.pickBy({ severity: 'trace', category, name, text }));
    }
    log(...messages) {
        const severity = this.options.severity || 'warning';
        const logCategory = this.options.logCategory;
        messages = messages
            .filter(message => severity === 'trace' ||
            (severity === 'info' && message.severity !== 'trace') ||
            (severity === 'warning' && (message.severity === 'warning' || message.severity === 'error')) ||
            (severity === 'error' && message.severity === 'error') ||
            (logCategory && message.category === logCategory))
            .map(message => {
            message = _.cloneDeep(message);
            if (message.source) {
                message.source.file = fileUrl(path.resolve(this.rootPath, message.source.file));
            }
            if (message.log) {
                message.log.file = fileUrl(path.resolve(this.rootPath, message.log.file));
            }
            return message;
        });
        if (messages.length > 0) {
            this.emit('log', messages);
        }
    }
    get components() {
        return this.state.components;
    }
    hasInput(rule, file, type) {
        return type
            ? this.state.edge(file.filePath, rule.id) === type
            : this.state.hasEdge(file.filePath, rule.id);
    }
    hasOutput(rule, file, type) {
        return type
            ? this.state.edge(rule.id, file.filePath) === type
            : this.state.hasEdge(rule.id, file.filePath);
    }
    addInput(rule, file, type) {
        this.state.addEdge(file.filePath, rule.id, type);
    }
    addOutput(rule, file, type) {
        this.state.addEdge(rule.id, file.filePath, type);
    }
    removeInput(rule, file) {
        this.state.removeEdge(file.filePath, rule.id);
    }
    removeOutput(rule, file) {
        this.state.removeEdge(rule.id, file.filePath);
    }
    isGrandparentOf(x, y) {
        return this.state.isGrandparentOf(x, y);
    }
    getResolvedFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getFile(this.resolvePath(filePath));
        });
    }
    addListener(event, listener) {
        this.state.addListener(event, listener);
        return this;
    }
    emit(event, ...args) {
        return this.state.emit(event, ...args);
    }
    eventNames() {
        return this.state.eventNames();
    }
    getMaxListeners() {
        return this.state.getMaxListeners();
    }
    listenerCount(event) {
        return this.state.listenerCount(event);
    }
    listeners(event) {
        return this.state.listeners(event);
    }
    on(event, listener) {
        this.state.on(event, listener);
        return this;
    }
    once(event, listener) {
        this.state.once(event, listener);
        return this;
    }
    prependListener(event, listener) {
        this.state.prependListener(event, listener);
        return this;
    }
    prependOnceListener(event, listener) {
        this.state.prependOnceListener(event, listener);
        return this;
    }
    rawListeners(event) {
        return this.state.rawListeners(event);
    }
    removeAllListeners(event) {
        this.state.removeAllListeners(event);
        return this;
    }
    removeListener(event, listener) {
        this.state.removeListener(event, listener);
        return this;
    }
    setMaxListeners(n) {
        this.state.setMaxListeners(n);
        return this;
    }
    /**
     * Kill all child processes.
     */
    killChildProcesses() {
        for (const pid of this.state.processes.values()) {
            kill(pid);
        }
        this.state.processes.clear();
    }
    /**
     * Execute a child process
     * @param  {string}                  command The command line. Should be quoted.
     * @param  {object}                  options Options passed to spawn.
     * @return {Promise<ProcessResults>}         Result of process including output.
     */
    executeChildProcess(command, options) {
        return new Promise((resolve, reject) => {
            let stdout;
            let stderr;
            let exited = false;
            const child = childProcess.spawn(command, options);
            const handleExit = (error) => {
                if (exited)
                    return;
                exited = true;
                if (child.pid)
                    this.state.processes.delete(child.pid);
                if (error) {
                    reject(error);
                }
                else {
                    resolve({ stdout, stderr });
                }
            };
            if (child.pid)
                this.state.processes.add(child.pid);
            child.on('error', handleExit);
            child.on('close', (code, signal) => {
                let error;
                if (code !== 0 || signal !== null) {
                    error = new Error(`Command failed: \`${command}\`\n${stderr || ''}`.trim());
                    error.code = code;
                    error.signal = signal;
                }
                handleExit(error);
            });
            if (child.stdout) {
                child.stdout.setEncoding('utf8');
                child.stdout.on('data', (data) => { stdout = `${stdout || ''}${data}`; });
            }
            if (child.stderr) {
                child.stderr.setEncoding('utf8');
                child.stderr.on('data', (data) => { stderr = `${stderr || ''}${data}`; });
            }
        });
    }
    isOutputOf(file, ruleId) {
        return this.state.isOutputOf(file, ruleId);
    }
    getJobOptions(jobName = null) {
        return this.state.getJobOptions(jobName);
    }
    getInputRules(file) {
        return this.state.getInputRules(file);
    }
    getOutputRules(file) {
        return this.state.getOutputRules(file);
    }
    getInputFiles(rule) {
        return this.state.getInputFiles(rule);
    }
    getOutputFiles(rule) {
        return this.state.getOutputFiles(rule);
    }
    getRuleId(name, command, phase, jobName = null, parameters = []) {
        return this.state.getRuleId(name, command, phase, jobName, parameters);
    }
    addCachedRule(cache) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.getRuleId(cache.name, cache.command, cache.phase, cache.jobName, cache.parameters);
            let rule = this.state.getRule(cache.name, cache.command, cache.phase, cache.jobName, cache.parameters);
            if (!rule) {
                const RuleClass = this.ruleClasses.find(ruleClass => ruleClass.name === cache.name);
                if (!RuleClass) {
                    this.error(`Unable to create rule ${id} since there is no rule type named ${cache.name} available.`);
                    return;
                }
                const options = this.getJobOptions(cache.jobName);
                const parameters = yield this.getFiles(cache.parameters);
                if (parameters.length !== cache.parameters.length) {
                    this.warning(`Unable to create rule ${id} since not all parameters could be found.`);
                    return;
                }
                rule = new RuleClass(this.state, cache.command, cache.phase, options, parameters);
                yield rule.initialize();
                yield this.addRule(rule);
            }
            for (const input of cache.inputs) {
                yield rule.getInput(input.file, input.type);
            }
            for (const output of cache.outputs) {
                yield rule.getOutput(output.file, output.type);
            }
            if (rule.constructor.alwaysEvaluate || rule.outputs.length !== cache.outputs.length) {
                // At least one of the outputs is missing or the rule should always run.
                rule.addActions();
            }
            for (const input of rule.inputs) {
                yield rule.addFileActions(input);
            }
        });
    }
    addCachedFile(filePath, fileCache) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.state.getFile(filePath, fileCache);
        });
    }
}
exports.default = StateConsumer;
