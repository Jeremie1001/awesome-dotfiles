"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const commandJoin = require('command-join');
const StateConsumer_1 = require("./StateConsumer");
class Rule extends StateConsumer_1.default {
    constructor(state, command, phase, options, parameters = []) {
        super(state, options, true);
        this.parameters = [];
        this.actions = new Map();
        this.failures = new Set();
        this.parameters = parameters;
        this.command = command;
        this.phase = phase;
        this.id = state.getRuleId(this.constructor.name, command, phase, options.jobName, parameters.map(file => file.filePath));
        this.parameters.forEach((file, index) => {
            const { dir, base, name, ext } = path.parse(file.filePath);
            const rootPath = path.dirname(file.realFilePath);
            this.env[`FILEPATH_${index}`] = file.filePath;
            this.env[`ROOTDIR_${index}`] = rootPath;
            this.env[`DIR_${index}`] = dir || '.';
            this.env[`BASE_${index}`] = base;
            this.env[`NAME_${index}`] = name;
            this.env[`EXT_${index}`] = ext;
            if (options.jobName)
                file.jobNames.add(options.jobName);
            this.addInput(this, file);
        });
    }
    static analyzePhase(consumer, command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            const appliesToPhase = this.commands.has(command) && this.phases.has(phase) &&
                this.parameterTypes.length === 0;
            if (appliesToPhase && (yield this.isApplicable(consumer, command, phase))) {
                const rule = new this(consumer.state, command, phase, consumer.options);
                yield rule.initialize();
                if (this.alwaysEvaluate)
                    rule.addActions();
                return rule;
            }
        });
    }
    static analyzeFile(consumer, command, phase, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const rules = [];
            const appliesToFile = this.commands.has(command) && this.phases.has(phase) &&
                this.parameterTypes.some(types => file && file.inTypeSet(types));
            if (appliesToFile) {
                const files = Array.from(consumer.files).filter(file => !consumer.options.jobName || file.jobNames.has(consumer.options.jobName));
                for (let i = 0; i < this.parameterTypes.length; i++) {
                    if (file.inTypeSet(this.parameterTypes[i])) {
                        const candidates = this.parameterTypes.map((types, index) => (index === i)
                            ? [file]
                            : files.filter(file => file.inTypeSet(types)));
                        let indicies = candidates.map(files => files.length - 1);
                        while (indicies.every(index => index > -1)) {
                            const parameters = candidates.map((files, index) => files[indicies[index]]);
                            const ruleId = consumer.getRuleId(this.name, command, phase, consumer.options.jobName, parameters.map(file => file.filePath));
                            if (!consumer.hasRule(ruleId) && (yield this.isApplicable(consumer, command, phase, parameters))) {
                                const rule = new this(consumer.state, command, phase, consumer.options, parameters);
                                yield rule.initialize();
                                if (this.alwaysEvaluate)
                                    rule.addActions(file);
                                rules.push(rule);
                            }
                            let j = 0;
                            while (j < indicies.length && --indicies[j] < 0) {
                                indicies[j] = candidates[j].length - 1;
                                j++;
                            }
                            if (j === indicies.length)
                                break;
                        }
                    }
                }
            }
            return rules;
        });
    }
    static isApplicable(consumer, command, phase, parameters = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    error(text, category, name) {
        super.error(text, category, name || this.id);
    }
    warning(text, category, name) {
        super.warning(text, category, name || this.id);
    }
    info(text, category, name) {
        super.info(text, category, name || this.id);
    }
    trace(text, category, name) {
        super.trace(text, category, name || this.id);
    }
    /* tslint:disable:no-empty */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    phaseInitialize(command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (command === this.command && phase === this.phase && this.constructor.alwaysEvaluate) {
                if (this.inputs.length === 0) {
                    this.addActions();
                }
                else {
                    for (const input of this.inputs) {
                        this.addActions(input, yield this.getFileActions(input));
                    }
                }
            }
        });
    }
    addFileActions(file, command, phase) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((!command || command === this.command) && (!phase || phase === this.phase) && file.hasBeenUpdated) {
                const timeStamp = this.timeStamp;
                const ruleNeedsUpdate = !timeStamp || timeStamp < file.timeStamp;
                for (const action of yield this.getFileActions(file)) {
                    if (ruleNeedsUpdate)
                        this.failures.delete(action);
                    if (action === 'updateDependencies' || ruleNeedsUpdate) {
                        this.addActions(file, [action]);
                    }
                }
            }
        });
    }
    getFileActions(file) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.constructor.defaultActions;
        });
    }
    addActions(file, actions) {
        if (!actions)
            actions = this.constructor.defaultActions;
        for (const action of actions || []) {
            const files = this.actions.get(action);
            if (!files) {
                this.actions.set(action, new Set(file ? [file] : []));
            }
            else if (file) {
                files.add(file);
            }
        }
    }
    get firstParameter() {
        return this.parameters[0];
    }
    get secondParameter() {
        return this.parameters[1];
    }
    get thirdParameter() {
        return this.parameters[2];
    }
    get needsEvaluation() {
        return this.actions.size !== 0;
    }
    get timeStamp() {
        return this.outputs.reduce((timestamp, file) => !timestamp || file.timeStamp > timestamp ? file.timeStamp : timestamp, undefined);
    }
    get inputs() {
        return this.getInputFiles(this);
    }
    get outputs() {
        return this.getOutputFiles(this);
    }
    preEvaluate() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    evaluate(action) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let success = true;
                yield this.preEvaluate();
                if (!this.actions.has(action))
                    return true;
                this.actionTrace(action);
                switch (action) {
                    case 'parse':
                        success = yield this.parse();
                        break;
                    case 'updateDependencies':
                        success = yield this.updateDependencies();
                        break;
                    default:
                        success = yield this.run();
                        break;
                }
                if (success) {
                    this.failures.delete(action);
                }
                else {
                    this.failures.add(action);
                }
                this.actions.delete(action);
                yield this.updateOutputs();
                return success;
            }
            catch (error) {
                this.error(error.stack);
            }
            return false;
        });
    }
    updateDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            const files = this.actions.get('updateDependencies');
            if (files) {
                for (const file of files.values()) {
                    const parsedLog = file.value;
                    if (parsedLog) {
                        if (parsedLog.inputs)
                            yield this.getInputs(parsedLog.inputs);
                        if (parsedLog.outputs)
                            yield this.getOutputs(parsedLog.outputs);
                    }
                }
            }
            return true;
        });
    }
    resolveAllPaths(value) {
        return value.replace(/\{\{(.*?)\}\}/, (match, filePath) => this.resolvePath(filePath));
    }
    executeCommand(commandOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // We only capture stdout and stderr if explicitly instructed to. This is
                // possibly to conserve some memory, but mostly it is a work around for a
                // bug in CLISP <https://sourceforge.net/p/clisp/bugs/378/> which makes it
                // impossible to run xindy without pseudo terminal support.
                const options = this.constructProcessOptions(commandOptions.cd, false, !!commandOptions.stdout, !!commandOptions.stderr);
                // Use ampersand as a filler for empty arguments. This is to work around
                // a bug in command-join.
                const command = commandJoin(commandOptions.args.map(arg => this.resolveAllPaths(arg) || '&'))
                    .replace(/(['"])\^?&(['"])/g, '$1$2');
                this.info(`Executing \`${command}\``, 'command');
                const result = yield this.executeChildProcess(command, options);
                if (commandOptions.inputs) {
                    for (const dependency of commandOptions.inputs) {
                        yield this.getResolvedInput(dependency.file, dependency.type);
                    }
                }
                if (commandOptions.outputs) {
                    for (const dependency of commandOptions.outputs) {
                        yield this.getResolvedOutput(dependency.file, dependency.type);
                    }
                }
                if (commandOptions.globbedInputs) {
                    for (const dependency of commandOptions.globbedInputs) {
                        yield this.getGlobbedInputs(dependency.file, dependency.type);
                    }
                }
                if (commandOptions.globbedOutputs) {
                    for (const dependency of commandOptions.globbedOutputs) {
                        yield this.getGlobbedOutputs(dependency.file, dependency.type);
                    }
                }
                if (typeof commandOptions.stdout === 'string') {
                    const output = yield this.getResolvedOutput(commandOptions.stdout);
                    if (output)
                        output.value = result.stdout;
                }
                if (typeof commandOptions.stderr === 'string') {
                    const output = yield this.getResolvedOutput(commandOptions.stderr);
                    if (output)
                        output.value = result.stderr;
                }
                return result;
            }
            catch (error) {
                this.log({ severity: commandOptions.severity, text: error.toString(), name: this.constructor.name });
                throw error;
            }
        });
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const commandOptions = this.constructCommand();
                yield this.executeCommand(commandOptions);
                return true;
            }
            catch (error) {
                return false;
            }
        });
    }
    parse() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    getOutput(filePath, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = yield this.getFile(filePath);
            if (file && !this.hasOutput(this, file, type)) {
                this.addOutput(this, file, type);
                this.trace(`Output added: \`${file.filePath}\``, 'output');
            }
            return file;
        });
    }
    getOutputs(filePaths, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of filePaths) {
                const file = yield this.getOutput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    updateOutputs() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const file of this.outputs) {
                if (yield file.update()) {
                    this.trace(`File changed: \`${file.filePath}\``, 'file');
                }
            }
        });
    }
    getInput(filePath, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let file = yield this.getFile(filePath);
            if (file && !this.hasInput(this, file, type)) {
                this.addInput(this, file, type);
                this.trace(`Input added: \`${file.filePath}\``, 'input');
            }
            return file;
        });
    }
    getInputs(filePaths, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of filePaths) {
                const file = yield this.getInput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    removeFileFromRule(file) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeInput(this, file);
            this.removeOutput(this, file);
            return this.parameters.includes(file);
        });
    }
    getResolvedInput(filePath, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const expanded = this.resolvePath(filePath);
            return this.getInput(expanded, type);
        });
    }
    getResolvedInputs(filePaths, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of filePaths) {
                const file = yield this.getResolvedInput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    getResolvedOutput(filePath, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const expanded = this.resolvePath(filePath);
            return this.getOutput(expanded, type);
        });
    }
    getResolvedOutputs(filePaths, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of filePaths) {
                const file = yield this.getResolvedOutput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    getGlobbedInputs(pattern, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of yield this.globPath(pattern)) {
                const file = yield this.getInput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    getGlobbedOutputs(pattern, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (const filePath of yield this.globPath(pattern)) {
                const file = yield this.getOutput(filePath, type);
                if (file)
                    files.push(file);
            }
            return files;
        });
    }
    constructProcessOptions(cd, stdin, stdout, stderr) {
        const processOptions = {
            cwd: this.resolvePath(cd),
            env: Object.assign({}, process.env),
            shell: true,
            stdio: [
                stdin ? 'pipe' : 'ignore',
                stdout ? 'pipe' : 'ignore',
                stderr ? 'pipe' : 'ignore'
            ]
        };
        for (const name in this.options) {
            if (!name.startsWith('$'))
                continue;
            const value = this.options[name];
            const envName = (process.platform === 'win32' && name === '$PATH') ? 'Path' : name.substring(1);
            if (Array.isArray(value)) {
                const emptyPath = (name === '$PATH') ? process.env[envName] || '' : '';
                const paths = value.map(filePath => filePath ? this.resolvePath(filePath.toString()) : emptyPath);
                if (processOptions.env[envName] && paths.length > 0 && paths[paths.length - 1] === '') {
                    paths[paths.length - 1] = processOptions.env[envName] || '';
                }
                processOptions.env[envName] = paths.join(path.delimiter);
            }
            else if (typeof value === 'string') {
                processOptions.env[envName] = this.expandVariables(value);
            }
            else {
                processOptions.env[envName] = value.toString();
            }
        }
        return processOptions;
    }
    constructCommand() {
        return { args: [], cd: '$ROOTDIR', severity: 'error' };
    }
    actionTrace(action) {
        const files = this.actions.get(action);
        const triggers = files ? Array.from(files).map(file => file.filePath) : [];
        const triggerText = triggers.length !== 0 ? ` triggered by updates to ${triggers}` : '';
        this.trace(`Evaluating ${action} action${triggerText}`, 'action');
    }
}
Rule.parameterTypes = [];
Rule.phases = new Set(['execute']);
Rule.commands = new Set(['build']);
Rule.alwaysEvaluate = false;
Rule.ignoreJobName = false;
Rule.defaultActions = ['run'];
Rule.description = '';
exports.default = Rule;
