"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphlib_1 = require("graphlib");
const events_1 = require("events");
const os = require("os");
const path = require("path");
const File_1 = require("./File");
function getLabel(x) {
    return (x instanceof File_1.default) ? x.filePath : x.id;
}
function getConfigHome() {
    // Even though Windows and MacOS do not follow the XDG Base Directory spec we
    // allow the environment variable XDG_CONFIG_HOME to override the platform's
    // default in case users want to maintain a consistent configuration setup
    // across multiple platforms.
    switch (process.platform) {
        case 'win32':
            return process.env.XDG_CONFIG_HOME || process.env.APPDATA ||
                path.join(os.homedir(), 'AppData', 'Roaming');
        case 'darwin':
            return process.env.XDG_CONFIG_HOME ||
                path.join(os.homedir(), 'Library', 'Application Support');
        default:
            return process.env.XDG_CONFIG_HOME || path.join(os.homedir(), '.config');
    }
}
class State extends events_1.EventEmitter {
    constructor(filePath, schema = []) {
        super();
        this.files = new Map();
        this.rules = new Map();
        this.options = {};
        this.optionSchema = new Map();
        this.ruleClasses = [];
        this.processes = new Set();
        this.graph = new graphlib_1.Graph();
        this.graphProperties = {};
        this.optionProxies = new Map();
        const resolveFilePath = path.resolve(filePath);
        const { dir, base, name, ext } = path.parse(resolveFilePath);
        this.filePath = base;
        this.rootPath = dir,
            this.graph.setDefaultEdgeLabel('default');
        this.defaultOptions = {};
        for (const option of schema) {
            this.optionSchema.set(option.name, option);
            for (const alias of option.aliases || []) {
                this.optionSchema.set(alias, option);
            }
            if (option.defaultValue)
                this.defaultOptions[option.name] = option.defaultValue;
        }
        this.resetOptions();
        this.env = Object.assign({}, process.env, {
            FILEPATH: base,
            ROOTDIR: dir,
            DIR: '.',
            BASE: base,
            NAME: name,
            EXT: ext,
            CONFIG_HOME: getConfigHome()
        });
        if (process.platform === 'win32') {
            Object.assign(this.env, {
                HOME: process.env.USERPROFILE,
                PATH: process.env.Path
            });
        }
    }
    normalizePath(filePath) {
        filePath = path.normalize(filePath);
        if (path.isAbsolute(filePath)) {
            const dirPaths = [
                this.rootPath
            ];
            for (const dir of dirPaths) {
                const candidateFilePath = path.relative(dir, filePath);
                if (!candidateFilePath.startsWith('..')) {
                    return candidateFilePath;
                }
            }
        }
        return filePath;
    }
    addRule(rule) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rules.set(rule.id, rule);
            this.addNode(rule.id);
            rule.addActions();
        });
    }
    removeRule(rule) {
        this.rules.delete(rule.id);
        this.removeNode(rule.id);
    }
    removeFile(file) {
        this.files.delete(file.filePath);
        this.removeNode(file.filePath);
    }
    getRuleId(name, command, phase, jobName = null, parameters = []) {
        const items = [command, phase, jobName || ''].concat(parameters);
        return `${name}(${items.join(';')})`;
    }
    getRule(name, command, phase, jobName = null, parameters = []) {
        const id = this.getRuleId(name, command, phase, jobName, parameters);
        return this.rules.get(id);
    }
    addNode(x) {
        this.graph.setNode(x);
        this.graphProperties = {};
    }
    removeNode(x) {
        this.graph.removeNode(x);
        this.graphProperties = {};
    }
    hasInEdge(x, type) {
        const edges = this.graph.inEdges(x);
        return !!edges && edges.some(edge => !type || this.graph.edge(edge) === type);
    }
    hasOutEdge(x, type) {
        const edges = this.graph.outEdges(x);
        return !!edges && edges.some(edge => !type || this.graph.edge(edge) === type);
    }
    hasEdge(x, y) {
        return this.graph.hasEdge(x, y);
    }
    edge(x, y) {
        return this.graph.edge(x, y);
    }
    addEdge(x, y, type = 'default') {
        this.graph.setEdge(x, y, type);
        this.graphProperties = {};
    }
    removeEdge(x, y) {
        this.graph.removeEdge(x, y);
        this.graphProperties = {};
    }
    getFile(filePath, fileCache) {
        return __awaiter(this, void 0, void 0, function* () {
            filePath = this.normalizePath(filePath);
            let file = this.files.get(filePath);
            if (!file) {
                file = yield File_1.default.create(path.resolve(this.rootPath, filePath), filePath, fileCache);
                if (!file) {
                    this.graph.removeNode(filePath);
                    return undefined;
                }
                this.addNode(filePath);
                this.files.set(filePath, file);
            }
            return file;
        });
    }
    resetOptions() {
        for (const name of Object.getOwnPropertyNames(this.options)) {
            delete this.options[name];
        }
        Object.assign(this.options, this.defaultOptions);
    }
    getJobOptions(jobName = null) {
        let optionProxy = this.optionProxies.get(jobName);
        if (!optionProxy) {
            optionProxy = new Proxy(this.options, {
                get: (target, name) => {
                    if (name === 'jobNames') {
                        if ('jobName' in target)
                            return [target.jobName];
                        if ('jobNames' in target)
                            return target.jobNames;
                        if ('jobs' in target)
                            return Object.keys(target.jobs);
                        return [null];
                    }
                    if (jobName) {
                        if (name === 'jobName')
                            return jobName;
                        if ('jobs' in target) {
                            const jobOptions = target.jobs[jobName];
                            if (jobOptions && name in jobOptions)
                                return jobOptions[name];
                        }
                    }
                    const schema = this.optionSchema.get(name.toString());
                    if (schema && schema.type === 'boolean') {
                        return !!target[name];
                    }
                    return (name === 'filePath') ? this.filePath : target[name];
                },
                ownKeys: target => {
                    const keys = new Set(['filePath', 'jobNames']);
                    if (jobName && 'jobs' in target) {
                        const jobOptions = target.jobs[jobName];
                        if (jobOptions)
                            Object.keys(jobOptions).forEach(key => keys.add(key));
                    }
                    this.optionSchema.forEach(option => {
                        if (option.type === 'boolean')
                            keys.add(option.name);
                    });
                    Object.keys(target).forEach(key => keys.add(key));
                    keys.delete('jobs');
                    return Array.from(keys.values());
                }
            });
            this.optionProxies.set(jobName, optionProxy);
        }
        return optionProxy;
    }
    get components() {
        if (!this.graphProperties.components) {
            this.graphProperties.components = graphlib_1.alg.components(this.graph)
                .map(component => component.map(id => this.rules.get(id)).filter(rule => rule))
                .filter(component => component.length > 0);
        }
        return this.graphProperties.components;
    }
    isGrandparentOf(x, y) {
        const xLabel = getLabel(x);
        const yLabel = getLabel(y);
        const predecessors = this.graph.predecessors(yLabel) || [];
        return predecessors.some(file => (this.graph.predecessors(file) || []).some(r => r === xLabel));
    }
    getInputRules(file) {
        const successors = this.graph.successors(file.filePath) || [];
        return successors.map(id => this.rules.get(id)).filter(rule => rule);
    }
    getOutputRules(file) {
        const predecessors = this.graph.predecessors(file.filePath) || [];
        return predecessors.map(id => this.rules.get(id)).filter(rule => rule);
    }
    isOutputOf(file, ruleId) {
        const inEdges = this.graph.inEdges(file.filePath) || [];
        return inEdges.some(edge => edge.v.startsWith(ruleId));
    }
    getInputFiles(rule) {
        const predecessors = this.graph.predecessors(rule.id) || [];
        return predecessors.map(filePath => this.files.get(filePath)).filter(file => file);
    }
    getOutputFiles(rule) {
        const successors = this.graph.successors(rule.id) || [];
        return successors.map(filePath => this.files.get(filePath)).filter(file => file);
    }
}
exports.default = State;
