"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rpc = require("vscode-jsonrpc");
class Server {
    constructor(transport, cache) {
        this.clearRequest = new rpc.RequestType1('clear');
        this.clearAllRequest = new rpc.RequestType0('clearAll');
        this.exitNotification = new rpc.NotificationType0('exit');
        this.getTargetsRequest = new rpc.RequestType1('getTargets');
        this.killRequest = new rpc.RequestType2('kill');
        this.killAllRequest = new rpc.RequestType1('killAll');
        this.logNotification = new rpc.NotificationType2('log');
        this.runRequest = new rpc.RequestType2('run');
        this.setDirectoryOptionsRequest = new rpc.RequestType3('setDirectoryOptions');
        this.setInstanceOptionsRequest = new rpc.RequestType3('setInstanceOptions');
        this.setProjectOptionsRequest = new rpc.RequestType3('setProjectOptions');
        this.setUserOptionsRequest = new rpc.RequestType3('setUserOptions');
        this.cache = cache;
        this.connection = rpc.createMessageConnection(transport[0], transport[1]);
        this.connection.onRequest(this.clearRequest, (file) => this.cache.clear(file));
        this.connection.onRequest(this.clearAllRequest, () => this.cache.clearAll());
        this.connection.onNotification(this.exitNotification, () => this.exit());
        this.connection.onRequest(this.getTargetsRequest, (file, absolute) => this.cache.getTargets(file));
        this.connection.onRequest(this.killRequest, (file, message) => this.cache.kill(file, message));
        this.connection.onRequest(this.killAllRequest, (message) => this.cache.killAll(message));
        this.connection.onRequest(this.runRequest, (file, commands) => this.cache.run(file, commands));
        this.connection.onRequest(this.setInstanceOptionsRequest, (file, options, merge) => this.cache.setInstanceOptions(file, options, merge));
        this.connection.onRequest(this.setUserOptionsRequest, (file, options, merge) => this.cache.setUserOptions(file, options, merge));
        this.connection.onRequest(this.setDirectoryOptionsRequest, (file, options, merge) => this.cache.setDirectoryOptions(file, options, merge));
        this.connection.onRequest(this.setProjectOptionsRequest, (file, options, merge) => this.cache.setProjectOptions(file, options, merge));
        this.cache.on('log', (file, messages) => {
            this.connection.sendNotification(this.logNotification, file, messages);
        });
    }
    start() {
        this.connection.listen();
    }
    exit() {
        process.exit(0);
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cache.destroy();
            this.exit();
        });
    }
}
exports.default = Server;
